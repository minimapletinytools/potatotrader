:: TODO TMRW::
IGNORE-add account abstracted version of some stuff in Chain and Bilaxy query (this is just in prep for using ExchangeAccount. We won't switch all the way over yet)
DONE-add monadic abstraction for some methods in chain and bilaxy query (also in preparation)
-write tests to ascertain units and exchange rate stuff is done correctly
  -i.e. write test cases for make_buyt1 and make_sell1t
  -for chain tests you can query the uniswap contract (and a block number) and run locally with the same numbers to ensure result is the same :D

::TODO::

- add test cases for all the chain query stuff D:
- reorg to give everything a package name
- Potato.Trading
- check if bilaxy is actually using bilaxy tokens to pay for txfees
- figure out if txfees are levied in first or second token on bilaxy
- Create `data FlipExchange e = FlipExchange e`
  -I'm pretty sure this is doable, just don't mess up buy/sell differences and do proper conversion for ExchangeRate functions

::FUTURE::
- accounts should not be read in IO monad. They should be passed in as an argument for each private exchange function (using data family for type)
- add mock interfaces for all IO monad calls for testing instead of actually querying exchanges...

:: OLD NOTES ::

trading algo at high level

parameters:

-exchange
  -pairs (market)

-market
  -buy orders
  -sell orders
  -delay
  -volatility?
    -needs to be measured in price and volume
    -needs to be measured as a chance as well?

-transaction
  -price
  -volume
  -fee
  -cancellation conditions?
  -risk assesment?
  -id

API

exchange

-startup
  -for each exchange
    -query existing transactions
      -cancel all of them?
  -query account balances
    -store them
  -read trading parameters
    -trading volume
    -risk
    -trading pairs? (hardcoded probably)

-monitoring
  -for each exchange
    -check pairs
      -generate exchange functions
  -for each transaction
    -if tx processed
      -log gain/loss
    -if tx need to be cancelled
      -log why it was cancelled
    -modify exchange function to include existing transactions
  -for each exchange function
    -check if new trade conditions are met
      -generate trades, send them and add them to list


logging


----------

TODO

-consider creating something like a monad for exchange operations
1. this monad must be used in the IO monad
2. this monad has a typed state for the exchange
3. this monad can be used across exchange pairs of the same exchange
